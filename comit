#!/bin/bash

# Professional Git commit utility
# Version: 5.0

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration directory
CONFIG_DIR="$HOME/.comit"
CONFIG_FILE="$CONFIG_DIR/config"
TOKEN_FILE="$CONFIG_DIR/token"

# Helper functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Create config directory if it doesn't exist
ensure_config_dir() {
    [[ ! -d "$CONFIG_DIR" ]] && mkdir -p "$CONFIG_DIR"
}

# Save configuration
save_config() {
    ensure_config_dir
    echo "$1=$2" >> "$CONFIG_FILE"
}

# Load configuration
load_config() {
    [[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"
}

# Save token securely
save_token() {
    ensure_config_dir
    echo "$1" > "$TOKEN_FILE"
    chmod 600 "$TOKEN_FILE"
}

# Load saved token
load_token() {
    [[ -f "$TOKEN_FILE" ]] && cat "$TOKEN_FILE"
}

# First-time setup wizard
setup_wizard() {
    echo -e "${BLUE}=== Git Shortcut Utility Setup ===${NC}\n"
    
    # Git configuration
    echo -e "${YELLOW}1. Git Configuration${NC}"
    CURRENT_NAME=$(git config --global user.name 2>/dev/null)
    CURRENT_EMAIL=$(git config --global user.email 2>/dev/null)
    
    if [[ -z "$CURRENT_NAME" ]]; then
        echo -n "Enter your full name: "
        read -r name
        git config --global user.name "$name"
        log_success "Name set to: $name"
    else
        echo "Current name: $CURRENT_NAME"
    fi
    
    if [[ -z "$CURRENT_EMAIL" ]]; then
        echo -n "Enter your email: "
        read -r email
        git config --global user.email "$email"
        log_success "Email set to: $email"
    else
        echo "Current email: $CURRENT_EMAIL"
    fi
    
    # GitHub token
    echo -e "\n${YELLOW}2. GitHub Token (Optional)${NC}"
    echo "For private repos and enhanced features"
    echo -n "Save GitHub token? (y/N): "
    read -r save_token_choice
    if [[ "$save_token_choice" =~ ^[Yy]$ ]]; then
        echo -n "Enter GitHub token: "
        read -rs token
        echo
        save_token "$token"
        log_success "Token saved securely"
    fi
    
    # Default settings
    echo -e "\n${YELLOW}3. Default Settings${NC}"
    git config --global init.defaultBranch main
    git config --global pull.rebase false
    git config --global core.autocrlf input
    log_success "Default settings configured"
    
    echo -e "\n${GREEN}Setup complete! You can now use 'comit' commands.${NC}"
    echo "Try: comit --help"
}

check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not a git repository. Please run 'git init' first."
        exit 1
    fi
}

get_current_branch() {
    git branch --show-current 2>/dev/null || echo "main"
}

show_help() {
    echo -e "${BLUE}Git Shortcut Utility v5.0${NC} - Replace complex Git commands with simple shortcuts\n"
    echo -e "${YELLOW}USAGE:${NC} comit [OPTION] [MESSAGE/TARGET]\n"
    
    echo -e "${YELLOW}═══ SETUP & CONFIGURATION ═══${NC}"
    echo "  --setup             Run first-time setup wizard (configure Git user, email, token)"
    echo "  --config            Show current Git configuration and optionally edit settings"
    echo "  --save-token        Save GitHub personal access token securely for future use"
    echo "  --ssh               Generate SSH key for GitHub and show setup instructions"
    echo "  --clone URL         Clone repository from URL and set up local workspace"
    echo "  --install-man       Install man page for comit command"
    echo "  --init              Initialize git repository with branch name and optional remote"
    echo -e "  -t, --token         Initialize new repository with GitHub token (interactive)\n"
    
    echo -e "${YELLOW}═══ BASIC COMMITS ═══${NC}"
    echo '  comit "message"     Standard workflow: git add . && git commit -m "message" && git push'
    echo '  -n, --no-push "msg" Commit without pushing: git add . && git commit -m "msg"'
    echo '  -f, --force "msg"   Force push commit: git add . && git commit -m "msg" && git push -f'
    echo '  -a, --amend "msg"   Amend last commit: git commit --amend -m "msg"'
    echo '  --fixup HASH "msg"  Create fixup commit: git commit --fixup=HASH -m "msg"'
    echo -e '  --wip "msg"         Work-in-progress: git add . && git commit -m "WIP: msg"\n'
    
    echo -e "${YELLOW}═══ BRANCH OPERATIONS ═══${NC}"
    echo '  -b, --branch NAME "msg"  Create new branch and commit: git checkout -b NAME && commit'
    echo "  -c, --checkout BRANCH    Switch to branch: git checkout BRANCH"
    echo "  --merge BRANCH           Merge branch into current: git merge BRANCH"
    echo "  --delete BRANCH          Delete branch safely: git branch -d BRANCH"
    echo -e '  --new-feature NAME "msg" Create feature branch, commit, and push with upstream\n'
    
    echo -e "${YELLOW}═══ WORKFLOW SHORTCUTS ═══${NC}"
    echo "  -p, --pull          Pull latest changes: git pull origin current-branch"
    echo "  --sync              Sync with remote: git pull && git push"
    echo '  --stash "msg"       Stash changes: git stash push -m "msg"'
    echo "  --unstash           Apply latest stash: git stash pop"
    echo '  --save "msg"        Quick save to stash: git add . && git stash push -m "msg"'
    echo "  --oops              Undo last commit (keep changes): git reset --soft HEAD~1"
    echo -e "  --undo              Same as --oops: git reset --soft HEAD~1\n"
    
    echo -e "${YELLOW}═══ ADVANCED OPERATIONS ═══${NC}"
    echo "  --squash N          Interactive rebase last N commits: git rebase -i HEAD~N"
    echo "  --clean             Clean workspace: git reset --hard HEAD && git clean -fd"
    echo "  -r, --reset         Reset to specific commit/branch (interactive)"
    echo "  --hard-reset BRANCH Hard reset and clean: git reset --hard BRANCH && git clean -fd"
    echo "  --sync-fork         Sync fork with upstream: fetch upstream && merge upstream/main"
    echo '  --hotfix "msg"      Create timestamped hotfix branch from main'
    echo "  --release TAG       Create and push release tag: git tag -a TAG && git push origin TAG"
    echo -e "  --remote            Show remote repositories: git remote -v\n"
    
    echo -e "${YELLOW}═══ INFORMATION & STATUS ═══${NC}"
    echo "  -s, --status        Short status: git status --short"
    echo "  -l, --log           Recent commits: git log --oneline"
    echo "  --diff              Show changes: git diff"
    echo "  --tree              Visual commit tree: git log --graph --oneline --all -15"
    echo "  --who               Contributor stats: git shortlog -sn"
    echo "  --size              Repository size: git count-objects -vH"
    echo "  -r, --remote        Show remote repositories: git remote -v"
    echo "  -h, --help          Show this help message"
    echo -e "  -v, --version       Show version information\n"
    
    echo -e "${YELLOW}═══ PRACTICAL EXAMPLES ═══${NC}"
    echo -e "  ${GREEN}Setup and Configuration:${NC}"
    echo "    comit --setup                           # First-time setup wizard"
    echo "    comit --save-token                      # Save GitHub token"
    echo "    comit --ssh                             # Generate SSH key for GitHub"
    echo -e "    comit --config                          # View/edit configuration\n"
    
    echo -e "  ${GREEN}Daily Workflow:${NC}"
    echo '    comit "Fix authentication bug"          # Standard: add, commit, push'
    echo '    comit -n "Work in progress"             # Commit without pushing'
    echo '    comit --wip "Testing new feature"       # Quick WIP commit'
    echo "    comit -p                                # Pull latest changes"
    echo -e "    comit --sync                            # Sync with remote\n"
    
    echo -e "  ${GREEN}Branch Management:${NC}"
    echo '    comit -b feature/login "Start login"    # Create branch and commit'
    echo "    comit -c main                           # Switch to main branch"
    echo "    comit --merge feature/login             # Merge feature branch"
    echo -e "    comit --delete feature/login            # Delete merged branch\n"
    
    echo -e "  ${GREEN}Advanced Operations:${NC}"
    echo "    comit --squash 3                        # Squash last 3 commits"
    echo '    comit --hotfix "Fix critical bug"       # Emergency hotfix workflow'
    echo "    comit --release v1.2.0                 # Create release tag"
    echo -e "    comit --hard-reset main                 # Hard reset to main\n"
    
    echo -e "  ${GREEN}Repository Setup:${NC}"
    echo "    comit --clone https://github.com/user/repo  # Clone and setup"
    echo -e "    comit --token                           # Initialize repo with GitHub\n"
    
    echo -e "  ${GREEN}Quick Info:${NC}"
    echo "    comit -s                                # Quick status"
    echo "    comit --tree                            # Visual commit history"
    echo -e "    comit --who                             # See contributors\n"
    
    echo -e "${YELLOW}═══ NOTES ═══${NC}"
    echo "• All commands work from any subdirectory within a Git repository"
    echo "• Use quotes around commit messages containing spaces or special characters"
    echo "• Force operations (--force, --hard-reset) require confirmation for safety"
    echo "• Setup wizard (--setup) configures Git globally for optimal comit usage"
    echo "• GitHub token enables private repository operations and enhanced features"
    echo "• Man page available after running: comit --install-man"
}

show_version() {
    echo -e "${BLUE}Git Shortcut Utility v5.0${NC}"
    echo "Repository: https://github.com/Elouahabi-Naoufal/comit"
    echo "Documentation: man comit (after running --install-man)"
}

# Parse arguments
OPTION=""
MESSAGE=""
TARGET=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        -s|--status)
            check_git_repo
            git status --short
            exit 0
            ;;
        -l|--log)
            check_git_repo
            git log --oneline
            exit 0
            ;;
        --diff)
            check_git_repo
            git diff
            exit 0
            ;;
        -p|--pull)
            OPTION="pull"
            shift
            ;;
        -n|--no-push)
            OPTION="no-push"
            shift
            ;;
        -f|--force)
            OPTION="force"
            shift
            ;;
        -a|--amend)
            OPTION="amend"
            shift
            ;;
        --fixup)
            OPTION="fixup"
            TARGET="$2"
            shift 2
            ;;
        -b|--branch)
            OPTION="branch"
            TARGET="$2"
            shift 2
            ;;
        -c|--checkout)
            OPTION="checkout"
            TARGET="$2"
            shift 2
            ;;
        --merge)
            OPTION="merge"
            TARGET="$2"
            shift 2
            ;;
        --delete)
            OPTION="delete"
            TARGET="$2"
            shift 2
            ;;
        --stash)
            OPTION="stash"
            shift
            ;;
        --unstash)
            OPTION="unstash"
            shift
            ;;
        --undo)
            OPTION="undo"
            shift
            ;;
        -r|--remote)
            check_git_repo
            git remote -v
            exit 0
            ;;
        --reset)
            OPTION="reset"
            shift
            ;;
        --hard-reset)
            OPTION="hard-reset"
            TARGET="$2"
            shift 2
            ;;
        --config)
            OPTION="config"
            shift
            ;;
        --sync)
            OPTION="sync"
            shift
            ;;
        --save)
            OPTION="save"
            shift
            ;;
        --wip)
            OPTION="wip"
            shift
            ;;
        --oops)
            OPTION="oops"
            shift
            ;;
        --squash)
            OPTION="squash"
            TARGET="$2"
            shift 2
            ;;
        --clean)
            OPTION="clean"
            shift
            ;;
        --sync-fork)
            OPTION="sync-fork"
            shift
            ;;
        --new-feature)
            OPTION="new-feature"
            TARGET="$2"
            shift 2
            ;;
        --hotfix)
            OPTION="hotfix"
            shift
            ;;
        --release)
            OPTION="release"
            TARGET="$2"
            shift 2
            ;;
        --tree)
            check_git_repo
            git log --graph --oneline --all -15
            exit 0
            ;;
        --who)
            check_git_repo
            git shortlog -sn
            exit 0
            ;;
        --size)
            check_git_repo
            git count-objects -vH
            exit 0
            ;;
        --setup)
            setup_wizard
            exit 0
            ;;
        --save-token)
            echo -n "Enter GitHub token: "
            read -rs token
            echo
            save_token "$token"
            log_success "Token saved securely"
            exit 0
            ;;
        --ssh)
            OPTION="ssh"
            shift
            ;;
        --clone)
            OPTION="clone"
            TARGET="$2"
            shift 2
            ;;
        --install-man)
            OPTION="install-man"
            shift
            ;;
        --init)
            OPTION="init"
            shift
            ;;
        -t|--token)
            OPTION="token"
            shift
            ;;
        -*)
            log_error "Unknown option: $1"
            echo "Use 'comit --help' for usage information."
            exit 1
            ;;
        *)
            MESSAGE="$1"
            shift
            ;;
    esac
done

# Handle various options
case "$OPTION" in
    "pull")
        check_git_repo
        BRANCH=$(get_current_branch)
        log_info "Pulling latest changes from origin/$BRANCH..."
        if git pull origin "$BRANCH"; then
            log_success "Successfully pulled latest changes"
        else
            log_error "Failed to pull changes"
            exit 1
        fi
        exit 0
        ;;
    "branch")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Enter new branch name: "
            read -r TARGET
        fi
        if [[ -z "$TARGET" ]]; then
            log_error "Branch name cannot be empty"
            exit 1
        fi
        log_info "Creating and switching to branch: $TARGET"
        git checkout -b "$TARGET"
        log_success "Created and switched to branch: $TARGET"
        exit 0
        ;;
    "checkout")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Enter branch name to checkout: "
            read -r TARGET
        fi
        if [[ -z "$TARGET" ]]; then
            log_error "Branch name cannot be empty"
            exit 1
        fi
        log_info "Switching to branch: $TARGET"
        git checkout "$TARGET"
        log_success "Switched to branch: $TARGET"
        exit 0
        ;;
    "merge")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Enter branch to merge: "
            read -r TARGET
        fi
        CURRENT=$(get_current_branch)
        log_info "Merging $TARGET into $CURRENT..."
        git merge "$TARGET"
        log_success "Merged $TARGET into $CURRENT"
        exit 0
        ;;
    "delete")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Enter branch to delete: "
            read -r TARGET
        fi
        CURRENT=$(get_current_branch)
        if [[ "$TARGET" == "$CURRENT" ]]; then
            log_error "Cannot delete current branch. Switch to another branch first."
            exit 1
        fi
        echo -n "Delete branch '$TARGET'? (y/N): "
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git branch -d "$TARGET"
            log_success "Deleted branch: $TARGET"
        fi
        exit 0
        ;;
    "stash")
        check_git_repo
        if git diff --quiet && git diff --cached --quiet; then
            log_warning "No changes to stash"
        else
            git stash push -m "${MESSAGE:-Auto-stash $(date)}"
            log_success "Changes stashed"
        fi
        exit 0
        ;;
    "unstash")
        check_git_repo
        if git stash list | grep -q stash; then
            git stash pop
            log_success "Stash applied"
        else
            log_warning "No stashes found"
        fi
        exit 0
        ;;
    "undo")
        check_git_repo
        log_warning "Undoing last commit (keeping changes)..."
        git reset --soft HEAD~1
        log_success "Last commit undone, changes preserved"
        exit 0
        ;;
    "config")
        echo -e "${BLUE}=== Git Configuration ===${NC}"
        echo "Global User: $(git config --global user.name) <$(git config --global user.email)>"
        if git rev-parse --git-dir > /dev/null 2>&1; then
            echo "Local User: $(git config user.name 2>/dev/null || echo 'Not set') <$(git config user.email 2>/dev/null || echo 'Not set')>"
            echo "Remote: $(git remote get-url origin 2>/dev/null || echo 'No remote set')"
            echo "Branch: $(get_current_branch)"
        fi
        echo "Default Branch: $(git config --global init.defaultBranch || echo 'master')"
        [[ -f "$TOKEN_FILE" ]] && echo "GitHub Token: Saved" || echo "GitHub Token: Not saved"
        echo -e "\n${YELLOW}Edit configuration? (y/N):${NC}"
        read -r edit_config
        if [[ "$edit_config" =~ ^[Yy]$ ]]; then
            setup_wizard
        fi
        exit 0
        ;;
    "sync")
        check_git_repo
        BRANCH=$(get_current_branch)
        log_info "Syncing with origin/$BRANCH..."
        git pull origin "$BRANCH" && git push origin "$BRANCH"
        log_success "Synced with remote"
        exit 0
        ;;
    "save")
        check_git_repo
        git add .
        git stash push -m "${MESSAGE:-Quick save $(date '+%H:%M')}"
        log_success "Changes saved to stash"
        exit 0
        ;;
    "wip")
        check_git_repo
        git add .
        git commit -m "WIP: ${MESSAGE:-work in progress}"
        log_success "WIP commit created"
        exit 0
        ;;
    "oops")
        check_git_repo
        git reset --soft HEAD~1
        log_success "Last commit undone (changes kept)"
        exit 0
        ;;
    "squash")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Number of commits to squash: "
            read -r TARGET
        fi
        if [[ ! "$TARGET" =~ ^[0-9]+$ ]]; then
            log_error "Please enter a valid number"
            exit 1
        fi
        log_info "Starting interactive rebase for last $TARGET commits..."
        git rebase -i HEAD~"$TARGET"
        exit 0
        ;;
    "clean")
        check_git_repo
        log_warning "This will remove all uncommitted changes!"
        echo -n "Are you sure? (y/N): "
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git reset --hard HEAD && git clean -fd
            log_success "Workspace cleaned"
        fi
        exit 0
        ;;
    "sync-fork")
        check_git_repo
        log_info "Syncing fork with upstream..."
        git fetch upstream 2>/dev/null || { log_error "No upstream remote found"; exit 1; }
        git checkout main
        git merge upstream/main
        git push origin main
        log_success "Fork synced with upstream"
        exit 0
        ;;
    "new-feature")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Feature branch name: "
            read -r TARGET
        fi
        BRANCH="feature/$TARGET"
        log_info "Creating feature branch: $BRANCH"
        git checkout -b "$BRANCH"
        if [[ -n "$MESSAGE" ]]; then
            git add .
            git commit -m "$MESSAGE"
        fi
        git push -u origin "$BRANCH"
        log_success "Feature branch $BRANCH created and pushed"
        exit 0
        ;;
    "hotfix")
        check_git_repo
        HOTFIX="hotfix/$(date '+%Y%m%d-%H%M')"
        log_info "Creating hotfix branch: $HOTFIX"
        git checkout main
        git pull origin main
        git checkout -b "$HOTFIX"
        if [[ -n "$MESSAGE" ]]; then
            git add .
            git commit -m "HOTFIX: $MESSAGE"
            git push -u origin "$HOTFIX"
        fi
        log_success "Hotfix branch $HOTFIX ready"
        exit 0
        ;;
    "release")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Release tag (e.g., v1.0.0): "
            read -r TARGET
        fi
        log_info "Creating release tag: $TARGET"
        git tag -a "$TARGET" -m "Release $TARGET"
        git push origin "$TARGET"
        log_success "Release $TARGET created and pushed"
        exit 0
        ;;
    "ssh")
        log_info "Setting up SSH key for GitHub..."
        SSH_KEY="$HOME/.ssh/id_ed25519"
        if [[ ! -f "$SSH_KEY" ]]; then
            echo -n "Enter your email for SSH key: "
            read -r email
            ssh-keygen -t ed25519 -C "$email" -f "$SSH_KEY" -N ""
            eval "$(ssh-agent -s)"
            ssh-add "$SSH_KEY"
            log_success "SSH key generated"
        fi
        echo -e "\n${YELLOW}Copy this public key to GitHub:${NC}"
        cat "$SSH_KEY.pub"
        echo -e "\n${BLUE}Go to: https://github.com/settings/ssh/new${NC}"
        exit 0
        ;;
    "clone")
        if [[ -z "$TARGET" ]]; then
            echo -n "Enter repository URL: "
            read -r TARGET
        fi
        log_info "Cloning repository..."
        git clone "$TARGET"
        REPO_NAME=$(basename "$TARGET" .git)
        cd "$REPO_NAME" || exit 1
        log_success "Repository cloned and ready"
        echo "Current directory: $(pwd)"
        exit 0
        ;;
    "init")
        log_info "Initializing Git repository..."
        
        # Initialize git if not already done
        if [[ ! -d ".git" ]]; then
            git init
            log_success "Git repository initialized"
        else
            log_warning "Already a git repository"
        fi
        
        # Ask for branch name
        echo -n "Branch name (default: main): "
        read -r branch_name
        branch_name=${branch_name:-main}
        
        # Set default branch
        git branch -M "$branch_name"
        log_success "Default branch set to: $branch_name"
        
        # Ask for remote URL
        echo -n "Remote URL (optional, press Enter to skip): "
        read -r remote_url
        
        if [[ -n "$remote_url" ]]; then
            if git remote get-url origin > /dev/null 2>&1; then
                git remote set-url origin "$remote_url"
                log_success "Remote origin updated"
            else
                git remote add origin "$remote_url"
                log_success "Remote origin added"
            fi
        fi
        
        log_success "Repository initialization complete"
        exit 0
        ;;
    "token")
        # Try to load saved token first
        SAVED_TOKEN=$(load_token)
        
        echo -n "GitHub username: "
        read -r username
        echo -n "Repository name: "
        read -r reponame
        
        if [[ -n "$SAVED_TOKEN" ]]; then
            echo "Using saved GitHub token"
            token="$SAVED_TOKEN"
        else
            echo -n "GitHub token: "
            read -rs token
            echo
            echo -n "Save this token for future use? (y/N): "
            read -r save_choice
            if [[ "$save_choice" =~ ^[Yy]$ ]]; then
                save_token "$token"
                log_success "Token saved for future use"
            fi
        fi
        
        if [[ -z "$username" || -z "$reponame" || -z "$token" ]]; then
            log_error "All fields are required"
            exit 1
        fi
        
        if [[ -z "$MESSAGE" ]]; then
            echo -n "Initial commit message: "
            read -r MESSAGE
        fi
        
        log_info "Initializing repository..."
        
        # Check if already a git repo
        if [[ ! -d ".git" ]]; then
            git init
            git branch -M main
        fi
        
        git add .
        git commit -m "${MESSAGE:-Initial commit}"
        
        # Check if remote already exists
        if git remote get-url origin > /dev/null 2>&1; then
            log_warning "Remote 'origin' already exists, updating..."
            git remote set-url origin "https://$token@github.com/$username/$reponame.git"
        else
            git remote add origin "https://$token@github.com/$username/$reponame.git"
        fi
        
        git push -u origin main
        log_success "Repository initialized and pushed to GitHub"
        log_info "Repository URL: https://github.com/$username/$reponame"
        exit 0
        ;;
    "reset")
        check_git_repo
        echo -n "Enter reset target (commit/branch): "
        read -r target
        if [[ -z "$target" ]]; then
            log_error "Reset target cannot be empty"
            exit 1
        fi
        log_warning "Resetting to $target..."
        git reset --hard "$target" && git clean -fd
        log_success "Reset completed"
        exit 0
        ;;
    "hard-reset")
        check_git_repo
        if [[ -z "$TARGET" ]]; then
            echo -n "Enter branch or commit to hard reset to: "
            read -r TARGET
        fi
        if [[ -z "$TARGET" ]]; then
            log_error "Reset target cannot be empty"
            exit 1
        fi
        log_warning "Hard resetting to $TARGET and cleaning workspace..."
        echo -n "Are you sure? This will lose all local changes! (y/N): "
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git reset --hard "$TARGET" && git clean -fd
            log_success "Hard reset to $TARGET completed"
        else
            log_info "Operation cancelled"
        fi
        exit 0
        ;;
    "install-man")
        log_info "Installing comprehensive man page for comit..."
        
        # Create comprehensive man page content
        MAN_CONTENT=$(cat << 'EOF'
.TH COMIT 1 "2024" "Git Shortcut Utility v5.0" "User Commands"
.SH NAME
comit \- Professional Git shortcut utility to replace complex multi-step Git workflows

.SH SYNOPSIS
.B comit
[\fIOPTION\fR] [\fIMESSAGE\fR|\fITARGET\fR]
.br
.B comit
\fB\-\-setup\fR
.br
.B comit
\fB\-\-help\fR
.br
.B comit
\fB\-\-version\fR

.SH DESCRIPTION
.B comit
is a professional Git shortcut utility that replaces complex multi-step Git workflows with simple, memorable commands. Instead of typing multiple Git commands like \fBgit add .\fR, \fBgit commit -m "message"\fR, and \fBgit push\fR, you can accomplish the same task with a single \fBcomit "message"\fR command.
.PP
The utility provides over 40 Git operations through intuitive options, making Git workflows faster and more efficient for daily development tasks. It includes safety features like confirmation prompts for destructive operations, automatic repository checks, and colored output for better user experience.
.PP
Whether you\'re a beginner who finds Git intimidating or an experienced developer who wants to speed up your workflow, this tool streamlines common Git operations while maintaining full control over your repository.

.SH SETUP & CONFIGURATION
.TP
.B \-\-setup
Run the comprehensive first-time setup wizard. This interactive command configures your Git username, email, default branch settings, and optionally saves a GitHub personal access token for enhanced features. The wizard also sets up optimal Git defaults including pull.rebase=false and core.autocrlf=input.
.TP
.B \-\-config
Display current Git configuration including global and local user settings, remote repositories, current branch, and token status. Optionally launch the setup wizard to modify settings.
.TP
.B \-\-save\-token
Securely save a GitHub personal access token for future use with private repositories and enhanced GitHub integration features. The token is stored with restricted permissions (600) in ~/.comit/token.
.TP
.B \-\-ssh
Generate an ED25519 SSH key for GitHub authentication and display setup instructions. If a key already exists, it shows the public key for copying to GitHub. Automatically starts ssh-agent and adds the key.
.TP
.B \-\-clone \fIURL\fR
Clone a repository from the specified URL and automatically set up the local workspace. Changes to the cloned directory and displays the current path.
.TP
.B \-\-install\-man
Install the comprehensive man page for the comit command. Attempts system-wide installation first, falls back to user directory if sudo access is unavailable.
.TP
.B \-\-init
Initialize a new Git repository with interactive branch name selection and optional remote URL configuration. Handles existing repositories gracefully.
.TP
.B \-t, \-\-token
Interactive repository initialization with GitHub integration. Prompts for GitHub username, repository name, and uses saved token or requests new one. Creates initial commit and pushes to GitHub.

.SH BASIC COMMITS
.TP
.B comit "\fImessage\fR"
Standard workflow equivalent to: \fBgit add . && git commit -m "message" && git push\fR. This is the most commonly used command that stages all changes, commits with the provided message, and pushes to the current branch.
.TP
.B \-n, \-\-no\-push "\fImessage\fR"
Commit changes without pushing to remote repository. Equivalent to: \fBgit add . && git commit -m "message"\fR. Useful for local commits before pushing.
.TP
.B \-f, \-\-force "\fImessage\fR"
Commit and force push changes. Equivalent to: \fBgit add . && git commit -m "message" && git push -f\fR. Includes confirmation prompt for safety.
.TP
.B \-a, \-\-amend "\fImessage\fR"
Amend the last commit with new message or additional changes. If message is provided, updates commit message. Offers option to force push amended commit.
.TP
.B \-\-fixup \fICOMMIT\fR "\fImessage\fR"
Create a fixup commit for the specified commit hash. Useful for preparing commits for interactive rebase with autosquash.
.TP
.B \-\-wip "\fImessage\fR"
Create a work-in-progress commit. Equivalent to: \fBgit add . && git commit -m "WIP: message"\fR. Perfect for saving work without a formal commit message.

.SH BRANCH OPERATIONS
.TP
.B \-b, \-\-branch \fINAME\fR "\fImessage\fR"
Create new branch and commit changes. Equivalent to: \fBgit checkout -b NAME && git add . && git commit -m "message"\fR. Streamlines feature branch creation.
.TP
.B \-c, \-\-checkout \fIBRANCH\fR
Switch to specified branch. Equivalent to: \fBgit checkout BRANCH\fR. Provides interactive prompt if branch name not specified.
.TP
.B \-\-merge \fIBRANCH\fR
Merge specified branch into current branch. Equivalent to: \fBgit merge BRANCH\fR. Shows which branches are being merged.
.TP
.B \-\-delete \fIBRANCH\fR
Safely delete specified branch with confirmation prompt. Equivalent to: \fBgit branch -d BRANCH\fR. Prevents deletion of current branch.
.TP
.B \-\-new\-feature \fINAME\fR "\fImessage\fR"
Create feature branch with "feature/" prefix, commit changes, and push with upstream tracking. Comprehensive feature branch workflow.

.SH WORKFLOW SHORTCUTS
.TP
.B \-p, \-\-pull
Pull latest changes from origin for current branch. Equivalent to: \fBgit pull origin current-branch\fR. Shows success/failure status.
.TP
.B \-\-sync
Synchronize with remote repository. Equivalent to: \fBgit pull && git push\fR. Ensures local and remote are in sync.
.TP
.B \-\-stash "\fImessage\fR"
Stash changes with descriptive message. Equivalent to: \fBgit stash push -m "message"\fR. Uses timestamp if no message provided.
.TP
.B \-\-unstash
Apply and remove the most recent stash. Equivalent to: \fBgit stash pop\fR. Warns if no stashes exist.
.TP
.B \-\-save "\fImessage\fR"
Quick save changes to stash. Equivalent to: \fBgit add . && git stash push -m "message"\fR. Perfect for temporary work saving.
.TP
.B \-\-oops
Undo last commit while keeping changes in working directory. Equivalent to: \fBgit reset --soft HEAD~1\fR. Safe way to fix recent commits.
.TP
.B \-\-undo
Alias for --oops. Same functionality with alternative command name.

.SH ADVANCED OPERATIONS
.TP
.B \-\-squash \fIN\fR
Start interactive rebase to squash last N commits. Equivalent to: \fBgit rebase -i HEAD~N\fR. Validates N is a positive integer.
.TP
.B \-\-clean
Clean workspace by removing all uncommitted changes and untracked files. Equivalent to: \fBgit reset --hard HEAD && git clean -fd\fR. Requires confirmation for safety.
.TP
.B \-\-reset
Interactive reset to specific commit or branch. Prompts for target and performs: \fBgit reset --hard target && git clean -fd\fR.
.TP
.B \-\-hard\-reset \fIBRANCH\fR
Hard reset to specified branch and clean workspace. Equivalent to: \fBgit reset --hard BRANCH && git clean -fd\fR. Requires confirmation due to destructive nature.
.TP
.B \-\-sync\-fork
Synchronize forked repository with upstream. Equivalent to: \fBgit fetch upstream && git checkout main && git merge upstream/main && git push origin main\fR.
.TP
.B \-\-hotfix "\fImessage\fR"
Create timestamped hotfix branch from main. Switches to main, pulls latest, creates hotfix/YYYYMMDD-HHMM branch, and optionally commits changes.
.TP
.B \-\-release \fITAG\fR
Create annotated release tag and push to remote. Equivalent to: \fBgit tag -a TAG -m "Release TAG" && git push origin TAG\fR.

.SH INFORMATION & STATUS
.TP
.B \-s, \-\-status
Show short repository status. Equivalent to: \fBgit status --short\fR. Concise view of working directory state.
.TP
.B \-l, \-\-log
Show recent commits in one line format. Equivalent to: \fBgit log --oneline\fR. Quick commit history overview.
.TP
.B \-\-diff
Show changes in working directory. Equivalent to: \fBgit diff\fR. Displays unstaged changes.
.TP
.B \-\-tree
Visual commit tree showing branch relationships. Equivalent to: \fBgit log --graph --oneline --all -15\fR. Limited to 15 commits for readability.
.TP
.B \-\-who
Show contributor statistics. Equivalent to: \fBgit shortlog -sn\fR. Lists contributors by commit count.
.TP
.B \-\-size
Show repository size and object statistics. Equivalent to: \fBgit count-objects -vH\fR. Displays human-readable size information.
.TP
.B \-r, \-\-remote
Show remote repositories. Equivalent to: \fBgit remote -v\fR. Displays fetch and push URLs for all configured remotes.
.TP
.B \-h, \-\-help
Display comprehensive help message with all available commands, organized by category with practical examples.
.TP
.B \-v, \-\-version
Show version information and repository URL.

.SH EXAMPLES
.SS Basic Daily Workflow
.TP
.B comit "Fix authentication bug"
Standard commit workflow - stages all changes, commits with message, and pushes to current branch.
.TP
.B comit -n "Work in progress"
Commit changes locally without pushing to remote repository.
.TP
.B comit --wip "Testing new feature"
Create work-in-progress commit with WIP prefix.
.TP
.B comit -p
Pull latest changes from remote repository.

.SS Branch Management
.TP
.B comit -b feature/login "Implement user login"
Create new feature branch and make initial commit.
.TP
.B comit -c main
Switch to main branch.
.TP
.B comit --merge feature/login
Merge feature branch into current branch.
.TP
.B comit --delete feature/login
Safely delete merged feature branch.

.SS Advanced Operations
.TP
.B comit --squash 3
Interactively squash last 3 commits.
.TP
.B comit --hotfix "Fix critical security vulnerability"
Create emergency hotfix branch with timestamp.
.TP
.B comit --release v1.2.0
Create and push release tag.
.TP
.B comit --hard-reset main
Hard reset current branch to main (destructive).

.SS Repository Setup
.TP
.B comit --setup
Run first-time configuration wizard.
.TP
.B comit --init
Initialize new Git repository with branch selection and optional remote.
.TP
.B comit --clone https://github.com/user/repo.git
Clone repository and set up workspace.
.TP
.B comit --token
Initialize repository with GitHub integration.

.SS Information Commands
.TP
.B comit -s
Quick repository status.
.TP
.B comit --tree
Visual commit history.
.TP
.B comit --who
Contributor statistics.
.TP
.B comit -r
Show remote repositories.

.SH CONFIGURATION
The comit utility stores configuration in \fB~/.comit/\fR directory:
.TP
.B ~/.comit/config
General configuration settings
.TP
.B ~/.comit/token
Securely stored GitHub personal access token (permissions: 600)
.PP
Global Git settings configured by --setup:
.TP
.B init.defaultBranch
Set to "main"
.TP
.B pull.rebase
Set to "false"
.TP
.B core.autocrlf
Set to "input"

.SH SAFETY FEATURES
The comit utility includes several safety mechanisms:
.TP
.B Confirmation Prompts
Destructive operations like --clean, --hard-reset, and --force require user confirmation.
.TP
.B Repository Validation
All commands verify you\'re in a Git repository before executing.
.TP
.B Branch Protection
Prevents deletion of current branch and warns about destructive operations.
.TP
.B Error Handling
Clear error messages with colored output for better visibility.
.TP
.B Graceful Fallbacks
Handles missing remotes, empty repositories, and network issues gracefully.

.SH EXIT STATUS
.TP
.B 0
Successful completion
.TP
.B 1
General error (not in git repository, network failure, etc.)

.SH FILES
.TP
.B ~/.comit/config
User configuration file
.TP
.B ~/.comit/token
Securely stored GitHub token
.TP
.B ~/.bashrc, ~/.zshrc
Shell configuration files (for PATH setup)

.SH ENVIRONMENT
.TP
.B PATH
Must include directory containing comit executable
.TP
.B HOME
Used for configuration directory location
.TP
.B MANPATH
Extended to include comit man page location

.SH BUGS
Report bugs and feature requests at: https://github.com/Elouahabi-Naoufal/comit/issues

.SH AUTHOR
Created by a developer frustrated with repetitive Git commands. Shared on GitHub to help fellow developers streamline their workflows.

.SH SEE ALSO
.BR git (1),
.BR git-add (1),
.BR git-commit (1),
.BR git-push (1),
.BR git-pull (1),
.BR git-branch (1),
.BR git-checkout (1),
.BR git-merge (1),
.BR git-stash (1),
.BR git-reset (1),
.BR git-rebase (1),
.BR git-tag (1)
EOF
)
        
        # Try to install to system location
        if sudo mkdir -p /usr/local/share/man/man1 2>/dev/null && echo "$MAN_CONTENT" | sudo tee /usr/local/share/man/man1/comit.1 > /dev/null 2>&1; then
            sudo mandb -q 2>/dev/null || true
            log_success "Man page installed to /usr/local/share/man/man1/comit.1"
            echo "You can now use: man comit"
        else
            # Fallback to user directory
            USER_MAN_DIR="$HOME/.local/share/man/man1"
            mkdir -p "$USER_MAN_DIR"
            echo "$MAN_CONTENT" > "$USER_MAN_DIR/comit.1"
            
            # Add to MANPATH if not already there
            if ! echo "$MANPATH" | grep -q "$HOME/.local/share/man"; then
                echo 'export MANPATH="$HOME/.local/share/man:$MANPATH"' >> "$HOME/.bashrc"
                log_warning "Added MANPATH to ~/.bashrc - restart terminal or run: source ~/.bashrc"
            fi
            
            log_success "Man page installed to $USER_MAN_DIR/comit.1"
            echo "You can now use: man comit (after restarting terminal)"
        fi
        exit 0
        ;;
esac

# Get commit message if not provided
if [[ -z "$MESSAGE" ]]; then
    echo -n "Commit message: "
    read -r MESSAGE
fi

if [[ -z "$MESSAGE" ]]; then
    log_error "Commit message cannot be empty"
    exit 1
fi

# Check if we're in a git repository
check_git_repo

# Smart algorithm: Check if there are changes to commit
if git diff --quiet && git diff --cached --quiet; then
    log_warning "No changes to commit"
    
    BRANCH=$(get_current_branch)
    
    # Check if there are unpushed commits on current branch
    if git log origin/$BRANCH..HEAD --oneline 2>/dev/null | grep -q .; then
        log_info "Found unpushed commits on $BRANCH, pushing..."
        if git push origin "$BRANCH"; then
            log_success "Successfully pushed unpushed commits to origin/$BRANCH"
        else
            log_error "Failed to push to $BRANCH"
            exit 1
        fi
        exit 0
    fi
    
    # If current branch is not main and no changes, offer to switch and push to main
    if [[ "$BRANCH" != "main" ]]; then
        log_info "Current branch: $BRANCH (no changes to commit)"
        echo -n "Switch to main and push? (Y/n): "
        read -r switch_to_main
        if [[ "$switch_to_main" =~ ^[Nn]$ ]]; then
            log_info "Staying on $BRANCH"
            exit 0
        fi
        
        log_info "Switching to main branch..."
        git checkout main
        BRANCH="main"
    fi
    
    # Check if main has unpushed commits
    if git log origin/main..HEAD --oneline 2>/dev/null | grep -q .; then
        log_info "Found unpushed commits on main, pushing..."
        if git push origin main; then
            log_success "Successfully pushed to origin/main"
        else
            log_error "Failed to push to main"
            exit 1
        fi
    else
        # Try to pull latest changes from main and then push
        log_info "No unpushed commits found. Checking for remote updates..."
        if git pull origin main --quiet 2>/dev/null; then
            log_info "Pulled latest changes from origin/main"
            if git push origin main 2>/dev/null; then
                log_success "Successfully synced with origin/main"
            else
                log_info "Already up to date with origin/main"
            fi
        else
            log_info "Already up to date with origin/main"
        fi
    fi
    exit 0
fi
fi

BRANCH=$(get_current_branch)
log_info "Committing changes to branch: $BRANCH"

# Stage and commit
git add .
git commit -m "$MESSAGE"
log_success "Changes committed: $MESSAGE"

# Handle commit options
case "$OPTION" in
    "amend")
        if [[ -n "$MESSAGE" ]]; then
            git commit --amend -m "$MESSAGE"
        else
            git commit --amend
        fi
        log_success "Commit amended"
        echo -n "Force push amended commit? (y/N): "
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git push -f origin "$BRANCH"
            log_success "Amended commit force pushed"
        fi
        ;;
    "fixup")
        if [[ -z "$TARGET" ]]; then
            log_error "Fixup target commit required"
            exit 1
        fi
        git add .
        git commit --fixup="$TARGET" -m "${MESSAGE:-fixup}"
        log_success "Fixup commit created for $TARGET"
        ;;
    "no-push")
        log_info "Skipping push (--no-push flag used)"
        ;;
    "force")
        log_warning "Force pushing to origin/$BRANCH..."
        echo -n "Are you sure? (y/N): "
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            git push -f origin "$BRANCH"
            log_success "Force pushed to origin/$BRANCH"
        else
            log_info "Push cancelled"
        fi
        ;;
    *)
        log_info "Pushing to origin/$BRANCH..."
        if git push origin "$BRANCH"; then
            log_success "Successfully pushed to origin/$BRANCH"
        else
            log_error "Failed to push. You may need to pull first."
            exit 1
        fi
        ;;
esac